# C++ primer 中文版
# Content
- [C++ primer 中文版](#c-primer-中文版)
- [Content](#content)
- [第1章-开始](#第1章-开始)
  - [1.1 编写一个简单的程序](#11-编写一个简单的程序)
  - [1.2 初识输入输出](#12-初识输入输出)
    - [标准输入输出对象](#标准输入输出对象)
      - [向流写入数据](#向流写入数据)
      - [`std::`](#std)
      - [向流读取数据](#向流读取数据)
  - [1.3 注释简介](#13-注释简介)
  - [1.4 控制流](#14-控制流)
    - [1.4.1 while语句](#141-while语句)
    - [1.4.2 for语句](#142-for语句)
    - [1.4.3 读取数量不确定的输入数据](#143-读取数量不确定的输入数据)
    - [1.4.4 if语句](#144-if语句)
  - [1.5 类简介](#15-类简介)
- [第一部分 C++基础](#第一部分-c基础)
  - [第二章 变量和基本类型](#第二章-变量和基本类型)
    - [2.1 基本内置类型](#21-基本内置类型)
      - [2.1.1 算数类型](#211-算数类型)
      - [2.1.2 类型转换](#212-类型转换)
      - [2.1.3 字面值常量`literal`](#213-字面值常量literal)
        - [整型](#整型)
        - [浮点型字面值](#浮点型字面值)
        - [字符字面值](#字符字面值)
        - [字符串字面值](#字符串字面值)
        - [转义序列`escape sequence`（事实上也是字符）](#转义序列escape-sequence事实上也是字符)
        - [指定字面值的类型](#指定字面值的类型)
        - [布尔和指针字面值](#布尔和指针字面值)
    - [2.2 变量](#22-变量)
      - [2.2.1 变量定义](#221-变量定义)
        - [列表初始化`list initialization`](#列表初始化list-initialization)
        - [默认初始化`default initialized`](#默认初始化default-initialized)

# 第1章-开始

## 1.1 编写一个简单的程序

1. return type 返回类型
2. function name 函数名
3. parameter list 参数列表
4. function body函数体
5. built-in type 内置类型
6. curly brace 左花括号
7. block of statement 语句块
8. Integrated developed environment IDE
9. source file 源文件

>一种类型不仅定义了数据元素的内容，还**定义了数据上可以进行的运算**

>在windows下运行可执行文件不需要添加扩展名

查看程序返回值
```bash
// Linux
echo $?

//Windows
echo %ERRORLEVEL%
```

**调用编译器**，生成**windows平台下的可执行文件**.exe
```bash
g++ -o prog1 prog1.cc
```

>GCC支援的语言大多在MinGW也受支援，其中涵盖C、C++、Objective-C、Fortran及Ada。**对于C语言之外的语言，MinGW使用标准的GNU运行时库，如C++使用GNU libstdc++。**但是MinGW使用Windows中的C运行时库。因此用MinGW开发的程序不需要额外的第三方DLL支持就可以直接在Windows下运行，而且也不一定必须遵从GPL许可证。这同时造成了MinGW开发的程序只能使用Win32API和跨平台的第三方库，而缺少POSIX支持[4]，大多数GNU软件无法在不修改源代码的情况下用MinGW编译。

>作为编译系统，Mingw32可以用来做Unix平台到windows平台的跨平台软件移植工作

>Cygwin 与 MinGW 皆可用来移植 Unix 软件到 Windows，但它们**采用截然不同的实作**。Cygwin 旨在提供一个完整的 POSIX 层，包括主流 Unix 的系统呼叫及函式库实作；其重视兼容性优先于性能。相对的，MinGW 则着重简化与性能。因此，它并不提供某些难以用 Windows API 实现的 POSIX API，例如 fork()，mmap() 和 ioctl()。使用跨平台函式库写成的应用程式，若函式库本身已移植到了 MinGW（例如 SDL、wxWidgets、Qt 或 GTK+），则那些应用程式通常也容易用 MinGW 编译。
用 Cygwin 写成的 Windows 程序，因为是执行在公共版权的兼容 DLL 上，所以 DLL 必须随著程序源代码一起发布。MinGW 则不需要兼容层，因为基于 MinGW 的程序是直接调用 Windows API 编译的。
MinGW 搭配 MSYS 可以产生一个小却完整的执行环境，让程式可以载入随身装置当中，却不动到注册表或产生额外档案。
在 POSIX 系统下，用 MinGW-GCC 交叉编译 Windows 应用程式也是可行的。这意味著开发者不需要安装 Windows 与 MSYS 才能编译 Windows 软件，或 Windows+Cygwin 软件。

## 1.2 初识输入输出

1. stream 流
2. standard input 标准输入
3. standard output 标准输出
4. standard error 标准错误
5. string literal 字符串字面值常量
6. manipulator 操纵符
7. namespace 命名空间
8. condition 条件

C++**没有定义任何输入输出语句**（和C语言一样）我们使用`iostream`库）

两种类型：`istream`和`ostream`分别代表输入流和输出流，是`iostream`标准库中定义的两个类型，流（stream）表达的是，随着时间的推移，字符**顺序产生&消耗**

### 标准输入输出对象

`cin`和`cout`分别是`istream`和`ostream`类型的对象
`cerr`和`clog`分别输出标准错误和日志

```cpp
#include<iostream>

int main(){
    std::cout << "Enter two numbers:" << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2 
            << " is " << v1 + v2 << std::endl;
    return 0;
}
```

#### 向流写入数据
C++的输出运算符：`<<`
1. 左侧运算对象必须是一个ostream类型对象
2. 右侧对象是要打印的值
3. 运算结果为左侧的运算对象
4. `std::endl`是一个**操纵符**特殊值，对标准输出对象输入该操纵符将结束当前行，将设备关联的**缓冲区内容刷新到页面上**，所以`cout`使用的是行缓冲
5. 标准库中定义了不同版本的输入输出运算符，故如下代码可以正常运转

```cpp
    std::cout << "The sum of " << v1 << " and " << v2 
            << " is " << v1 + v2 << std::endl;
```

>在调试的阶段如果需要使用`cout`来打印信息，记得使用`std::endl`来刷新缓冲区，这样就算程序崩溃，留在缓冲区的内容也会被及时打印到设备上

#### `std::`
1. `std::`指出，`cout`和`cin`是定义在名为`std`的命名空间中的
2. 命名空间的设定是为了防止名字冲突
3. `std`是标准库的命名空间
4. `::`作用域运算符

#### 向流读取数据
C++的输入运算符`>>`，返回左侧对象作为计算结果

## 1.3 注释简介

`/*...*/`注释**界定符**
1. 注释界定符不能嵌套
2. 单行注释将会把改行中的所有内容都忽略
3. `""`双引号之间的注释界定符没有注释的效果
4. 编译器遇到左界定符时，会注释掉所有的字符，直到右界定符

## 1.4 控制流

### 1.4.1 while语句

### 1.4.2 for语句

### 1.4.3 读取数量不确定的输入数据
```c++
while(std::cin>>x){
  ...
}
```
>原理：输入运算符返回左侧的对象，当使用`istream`对象作为条件时，可以起到检测流的状态，如果输入无效，比如类型不匹配，或是遇到EOF，则为`False`

故该循环停止的条件有二，其一为当遇到EOF时，其二为输入错误时

### 1.4.4 if语句

## 1.5 类简介

>C++中我们通过定义类来定义自己的数据结构
C++设计之初的焦点就是能够定义使用上像内置类型一样自然的**类类型**（class type）

1. 习惯上头文件通过其中定义的类的名字命名
2. 标准库头文件通常不带后缀
3. 标准库头文件使用`<>`，不属于标准库的头文件，使用`""`

>为了使用一个类，我们不需要知道其如何实现，只需要知道类对象可以执行什么操作
类也定义了类对象的行为

1. 成员函数（member function）是定义为类的一部分的函数，也被称为方法（methode）
2. 点运算符`.`返回指定的成员

# 第一部分 C++基础

和Python语言不同，C++的类型检查发生在编译阶段（静态类型语言）

## 第二章 变量和基本类型

>数据类型是程序的基础

字符，整数，浮点数

### 2.1 基本内置类型

两类基本内置类型：
1. arithmetic 算数类型
2. void 空类型

#### 2.1.1 算数类型
算数类型分为（*CSAPP第二章*）：
1. 整型
2. 浮点型

>事实上，函数返回值为空的`void`也是一种类型，C++还提供了布尔型，其取值为`True`, `False`

$$short \leq int \leq long \leq long long(C++11新定义)$$

1. 可寻址的最小内存块称为字节
2. 存储的基本单元为字
3. C++定义了`long double`，具体实现依赖于机器（因为不在IEEE754中）

>关于C++中`char`,`unsigned char`,`signed char`
`char`的具体实现取决于编译器

>一些选择变量类型的准则：
数值超过`int`的范围，选择`long long`
算术表达式中不适用`char`和`bool`，因为`char`的具体实现取决于机器，如果必要最好选择`unsigned char`或者`signed char`
浮点类型优先选择`double`，因为`float`通常精度不够（float单精度浮点的有效位数为23，或者24，换算为十进制大约是7位到8位，确实感觉捉襟见肘），且`float`和`double`的运算耗时相差无几，`long double`冗余且运算耗时不容忽视

#### 2.1.2 类型转换

程序应该尽量避免依赖于实现环境的行为，定位移植性错误是一件不容易的事情

总之需要小心不要随意混用无符号和有符号类型，且要考虑结果值的表示是否正确

```c++
unsigned u = 10, u2 = 42;
std::cout << u2 - u << std::endl;
// 32
std::cout << u - u2 << std::endl;
// Umax_32 - 32 = 4,294,967,264

int i = 10, i2 = 42;
std::cout << i2 - i << std::endl;
// 32
std::cout << i - i2 << std::endl;
// -32
std::cout << i - u << std::endl;
// 0
std::cout << u - i << std::endl;
// 0
```
牛！牛！牛！

#### 2.1.3 字面值常量`literal`

1. 一望而知的值被称为字面值常量
2. 每个字面值常量都有其数据类型
3. 其类型取决于字面值常量的形式和值

##### 整型

`024`,`0xFF`,`20`分别代表八进制，十六进制和十进制

1. 十进制字面值是带符号数，从`int`开始（但严格来说十进制字面值不可能是负数`-10`字面值为`10`，再对其取负）
2. 八进制和十六进制有可能是带符号数，也有可能是不带符号数，取决于其值的大小
3. 如果字面值过大产生溢出，将抛出错误

##### 浮点型字面值

`3.1415926`, `3.14159E0`, `0.`, `0e0`, `.001`

浮点字面值默认类型为double

##### 字符字面值

`'a'`

##### 字符串字面值

`"Hello world!"`
1. 常量字符构成的数组
2. 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，编译器将其认为是一个整体

##### 转义序列`escape sequence`（事实上也是字符）

`nonprintable`不可打印字符与特殊含义字符

![](https://img2018.cnblogs.com/blog/1485142/201908/1485142-20190811190958270-1141096506.jpg)

C++也支持**泛化的转义序列**

##### 指定字面值的类型

前缀（字符）：`u`,`U`,`L`,`u8`
后缀（整型）：`u/U`,`l/L`,`ll/LL`
后缀（浮点）：`f/F`,`l/L`

##### 布尔和指针字面值

`true`, `false`

`nullptr`

### 2.2 变量

>变量提供一个具有名字的可供程序操作的存储空间，对于C++程序员来说，变量（variable）和对象（object）一般可以互换使用，对象指的是一块能够存储数据并且具有某种类型的内存空间，值（value）指的是只读的数据

#### 2.2.1 变量定义

变量定义的形式：
$$类型说明符（type specifier）+变量名列表+;$$

在定义的时候可以给一个或者多个变量赋值，此时我们说这个变量**被初始化（initialized）**
变量名列表遵循从左至右的顺序被创建和初始化，可以使用先被初始化的变量来初始化随后的变量

`double price = 100, discount = price * 0.16;`

>初始化和赋值是两种完全不同的操作，虽然都使用`=`运算符，初始化的含义是创建变量的时候赋予其一个初始值，赋值的含义是将某变量之前的值擦去，用一个新值代替

##### 列表初始化`list initialization`

```c++
int units_sold = 0;

//C++11
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

>列表初始化的重要特性：形如`int units_sold{0};`这般的花括号初始化将会**自动检查是否出现信息丢失！**

##### 默认初始化`default initialized`

1. 默认值由**类型和定义变量的位置**决定
2. **函数体之外**的**内置类型变量**将被初始化为`0`
3. 而未被初始化的函数体内部的内置类型变量将**不被初始化**（uninitialized）
4. 每个类是否允许未经初始化就被定义完全由类自己决定（**粒度足够细**），试图拷贝或者以其他形式访问这个类将引发错误

  