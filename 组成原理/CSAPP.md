# CSAPP by Houze
# Content
- [CSAPP by Houze](#csapp-by-houze)
- [Content](#content)
  - [第一章-计算机系统漫游](#第一章-计算机系统漫游)
    - [1.1信息就是位+上下文](#11信息就是位上下文)
      - [ASCII](#ascii)
      - [编译系统](#编译系统)
        - [1.预处理阶段](#1预处理阶段)
        - [2.编译器阶段](#2编译器阶段)
        - [3.汇编阶段](#3汇编阶段)
        - [4.链接阶段](#4链接阶段)
    - [1.4处理器读并解释存储在内存中的指令](#14处理器读并解释存储在内存中的指令)
      - [1.4.1系统的硬件组成](#141系统的硬件组成)
        - [总线](#总线)
        - [IO设备（通过IO总线与）](#io设备通过io总线与)
        - [主存](#主存)
        - [处理器](#处理器)
        - [数据搬运问题](#数据搬运问题)
    - [1.6 存储器层次结构](#16-存储器层次结构)
    - [1.7 操作系统管理硬件](#17-操作系统管理硬件)
      - [1.7.1 进程](#171-进程)
      - [1.7.2 线程](#172-线程)
      - [1.7.3 虚拟内存](#173-虚拟内存)
    - [1.8 网络](#18-网络)
    - [1.9 总结](#19-总结)
      - [1.9.1 Amdahl定律（描述改善任何过程的一般原则）](#191-amdahl定律描述改善任何过程的一般原则)
      - [1.9.2 并发和并行](#192-并发和并行)
      - [1.9.3 抽象](#193-抽象)
- [第一部分-程序结构和执行](#第一部分-程序结构和执行)
  - [第二章-信息的表示和处理](#第二章-信息的表示和处理)
    - [2.1 信息存储](#21-信息存储)
      - [2.1.1 十六进制表示法](#211-十六进制表示法)
        - [练习2.1-转换规则练习：一位十六进制对应四位二进制](#练习21-转换规则练习一位十六进制对应四位二进制)
        - [练习2.2-2的n次方快速转换十六进制](#练习22-2的n次方快速转换十六进制)
        - [练习2.3-两位十六进制和二进制，十进制相互转换](#练习23-两位十六进制和二进制十进制相互转换)
        - [练习2.4-使用十六进制直接计算](#练习24-使用十六进制直接计算)
      - [2.1.2 字数据大小](#212-字数据大小)
      - [2.1.3 寻址和字节顺序](#213-寻址和字节顺序)
        - [练习2.5-思考对show_bytes的三次调用](#练习25-思考对show_bytes的三次调用)
        - [练习2.6 使用show_int和show_float](#练习26-使用show_int和show_float)
      - [2.1.4 表示字符串](#214-表示字符串)
        - [练习2.7-对show_bytes的调用将输出什么结果？](#练习27-对show_bytes的调用将输出什么结果)
      - [补充：Unicode](#补充unicode)
      - [2.1.6 布尔代数简介](#216-布尔代数简介)
        - [练习2.8-位向量的布尔运算](#练习28-位向量的布尔运算)
        - [练习2.9-三原色](#练习29-三原色)
      - [2.1.7 C位级运算](#217-c位级运算)
        - [练习2.10-inplace_swap](#练习210-inplace_swap)
        - [练习2.11-数组头尾对调](#练习211-数组头尾对调)
      - [补充：掩码运算](#补充掩码运算)
        - [练习2.12-写出C语言表达式](#练习212-写出c语言表达式)
        - [练习2.13-VAX计算机](#练习213-vax计算机)
      - [2.1.8 C逻辑运算](#218-c逻辑运算)
        - [练习2.14 计算表达式](#练习214-计算表达式)
        - [练习2.15 实现==](#练习215-实现)
      - [2.1.9 C移位运算](#219-c移位运算)
        - [左移](#左移)
        - [（算数/逻辑）右移](#算数逻辑右移)
        - [k很大](#k很大)
        - [移位运算的优先级问题](#移位运算的优先级问题)
        - [练习2.16 不同移位运算对字节数的影响](#练习216-不同移位运算对字节数的影响)
    - [2.2 整数表示](#22-整数表示)
      - [2.2.1 整型数据类型](#221-整型数据类型)
      - [2.2.2 无符号数编码（原码）](#222-无符号数编码原码)
      - [2.2.3 补码](#223-补码)
        - [练习2.17](#练习217)
      - [重要的数字](#重要的数字)
        - [练习2.18 将32位补码转换为十进制](#练习218-将32位补码转换为十进制)
      - [2.2.4 有符号数和无符号数之间的转换](#224-有符号数和无符号数之间的转换)
        - [练习2.19 填写T2U4的表格](#练习219-填写t2u4的表格)
        - [**原理：补码转换为无符号数**](#原理补码转换为无符号数)
        - [**推导：无符号数转化为补码**](#推导无符号数转化为补码)
      - [2.2.5 C语言中的有符号和无符号类型](#225-c语言中的有符号和无符号类型)
        - [练习2.21 补码运算的32位机器求值](#练习221-补码运算的32位机器求值)
      - [2.2.6 扩展一个数的位表示](#226-扩展一个数的位表示)
        - [无符号数zero extension](#无符号数zero-extension)
        - [补码数的符号扩展](#补码数的符号扩展)
      - [2.2.8 关于有符号和无符号数的建议](#228-关于有符号和无符号数的建议)
        - [练习2.25](#练习225)
        - [练习2.26-`size_t`定义为`unsigned int`](#练习226-size_t定义为unsigned-int)
    - [2.3 整数运算](#23-整数运算)
      - [2.3.1 无符号加法](#231-无符号加法)
        - [练习2.27-溢出检查函数](#练习227-溢出检查函数)
      - [2.3.2 补码加法](#232-补码加法)
        - [练习2.31 阿贝尔群](#练习231-阿贝尔群)
        - [练习2.32 取相反数](#练习232-取相反数)
      - [2.3.3 补码的非](#233-补码的非)
      - [2.3.4 无符号乘法](#234-无符号乘法)
      - [2.3.5 补码乘法](#235-补码乘法)
        - [练习2.37](#练习237)
      - [2.3.6 乘以常数](#236-乘以常数)
        - [练习2.38 `LEA`指令执行常数因子乘法](#练习238-lea指令执行常数因子乘法)
      - [2.3.7 除以2的幂](#237-除以2的幂)
    - [2.4 浮点数](#24-浮点数)
      - [2.4.2 IEEE浮点表示](#242-ieee浮点表示)
      - [2.4.3 数字示例](#243-数字示例)
      - [2.4.4 舍入](#244-舍入)
      - [2.4.5 浮点运算](#245-浮点运算)
  - [第三章-程序的机器级表示](#第三章-程序的机器级表示)
    - [3.1 历史观点](#31-历史观点)
    - [3.2 程序编码](#32-程序编码)
      - [3.2.1 机器级代码](#321-机器级代码)

## 第一章-计算机系统漫游

### 1.1信息就是位+上下文

C语言程序的生命周期从程序的**源文件**开始。***源程序***本质上是一个由0和1**比特**组成的**位序列**。八个位组成一组，称为**字节**

大写的B为字节，小写的b为比特位

事实上，系统中的所有信息，包括磁盘文件、内存中的程序、数据等都是**一串比特**构成的。

说的非常好，这就是为什么算法刷到一半，停下来看CSAPP的原因——位运算和除法的机制能搞明白吗？搞不明白算法题做得下去吗？
>作为程序员，我们需要了解数字的机器表示方式，因为他们与实际的整数和实数是不同的，他们是对真值的有限近似

事实上UNIX几乎全部由C语言编写，C语言的设计初衷也是为了编写UNIX操作系统

#### ASCII
单字节表示字符

`文本文件`只由ASCII字符构成的文件
`二进制文件`其他文件

#### 编译系统

**预处理器+编译器+汇编器+连接器构成编译系统（compilation system）**

`gcc -o hello hello.c`的四阶段
`gcc`是`GNU`项目的产物

![gcc](https://img-blog.csdnimg.cn/2018112322515411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTcxMzMw,size_16,color_FFFFFF,t_70)

##### 1.预处理阶段

修改了源程序的文本，直接插入

##### 2.编译器阶段

生成汇编语言程序——为不同的高级语言的不同编译器提供了通用的输出语言

##### 3.汇编阶段

将汇编程序翻译成机器语言，将指令打包成**可重定位目标程序**（relocatable object program），显然机器语言就是**二进制格式**了，不再是汇编格式了，此时的文件扩展名为`.o`

##### 4.链接阶段

将`printf.o`这个已经存在在**C标准库中的单独的已经预编译好的目标文件**和`hello.o`进行链接，最后生成**可执行文件**

### 1.4处理器读并解释存储在内存中的指令

#### 1.4.1系统的硬件组成

##### 总线
负责在各个电子部件之间传递数据，一般被设计为传递**定长的字节块**，需要注意，各个系统中对**字**的定义不尽相同（[字长](#212-字数据大小)到底有多长？），它是一个基本的**系统参数**。大多数设备要么是32位，要么是64位（4个字节为一个字，或者8个字节为一个字）

##### IO设备（通过IO总线与）
计算机与外部设备的连接通道，通过**控制器&适配器**和IO总线连接

##### 主存

| 物理                 | 逻辑                                                    |
| -------------------- | ------------------------------------------------------- |
| DRAM动态随机存储设备 | **字节**数组，且从**0**开始，每一个字节都有**唯一**地址 |

从物理上，主存是**DRAM动态随机存储设备**；逻辑上，主存是一个**线性[字节数组](#21-信息存储)**，且每个字节都有唯一的地址（数组索引），且该地址是从**零开始**的。

##### 处理器
解释或执行存储在主存中指令的引擎、其核心是**PC**（CS:IP）寄存器（程序计数器）。指令集的操作对象包括**主存**，CPU的**寄存器**与**ALU**算数/逻辑单元。**指令集架构**，指的是每条指令的效果，而**微体系结构**指处理器实际上的实现（包括对指令的大量优化）

##### 数据搬运问题
**DMA**直接存储器技术：数据能够从磁盘直接到达主存（性能优化）

**Cache Memory**高速缓存技术：分别设置L1，L2...不同级别不同速度不同容量的高速缓存，以优化机器的性能。使用**SRAM**（静态随机访问存储器，比它弱一级的是**DRAM**主存）技术实现。换句话说，高速缓存设置得越多，计算机搬运数据的开销越小

### 1.6 存储器层次结构

![上一级的存储器作为低一级的存储器的**高速缓存**](https://pic1.zhimg.com/v2-6d0755d5df8280a82b2249c53129ddd3_720w.jpg?source=172ae18b)

逻辑：上一级的存储器作为低一级的存储器的**高速缓存**

### 1.7 操作系统管理硬件

硬件和软件层之间插入的一层**软件**，所有的程序必须通过操作系统访问硬件。

操作系统的三大抽象：
| 抽象     | 设备                 |
| -------- | -------------------- |
| 文件     | IO设备               |
| 进程     | 处理器、主存和IO设备 |
| 虚拟内存 | 主存和磁盘IO         |

**UNIX**是**贝尔实验室**开发的，并且开发完毕之后给高校慷慨地提供源代码。造成了复杂操作系统的盛行，为了保持一致，电气电子工程师学会IEEE标准化了UNIX的开发，这个标准就是**POSIX**标准

#### 1.7.1 进程

进程是操作系统对一个**正在运行的程序**的一种抽象

**并发**：一个进程的指令和另一个进程的指令交错进行（机制：**上下文切换**）

**上下文**：操作系统保持跟踪进程所需的状态信息

例子：在bash中调用gcc生成的可执行程序，此时bash会使用系统调用，将控制权转交给**内核**，随后**内核**创建新的进程和上下文，保存bash的上下文，切换进程

什么是**内核**（kernel）？内核就是操作系统这个软件**常驻主存**的部分。当程序需要操作系统的某些操作的时候，会使用**system call**系统调用来将控制权转交给内核。内核并不是一个进程。

#### 1.7.2 线程

一个进程可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，共享同样的代码和数据。需要注意的是，线程往往比进程更加高效，因为他们交换数据更加容易。

#### 1.7.3 虚拟内存

给每个进程一个假象：独占地使用主存，这个统一的内存空间被称为虚拟地址空间
![虚拟地址空间](https://images0.cnblogs.com/i/569008/201405/270929306664122.jpg)

stack负责函数调用，heap负责管理运行时堆

### 1.8 网络

网络可以视为一个**IO设备**，**网络适配器**作为桥梁连接IO总线和网络

### 1.9 总结

系统是硬件和软件的结合

#### 1.9.1 Amdahl定律（描述改善任何过程的一般原则）

当我们对系统的某个部分加速的时候，其对系统的整体性能取决于**该部分的重要性**和**加速程度**

$$
\alpha - 初始占用时间
$$

$$
k - 该部分（环节）性能提升比 >= 1
$$

$$
S = {T_{old} \over T_{new}} = {{1} \over {(1 - a ) + {a \over k}}}
$$

观点：**想要显著加速整个系统，必须提升全部系统中相当大的部分的速度**

#### 1.9.2 并发和并行

并发（concurrency）——同时具有多个活动的系统  
并行（parallelism）——用并发来使系统运行得更快  

需要注意的是，并行可以在操作系统的多个抽象层次上使用

1. [线程](#172-线程)级并发——两方面（其一为操作系统级，其二为硬件级）  
支持在一个进程中执行多个控制流，事实上，在**单处理系统中**（单操作系统+单处理器），这种并发也只是模拟出来的。

多处理器系统将**多块cpu集成到一块电路芯片**上，这些CPU同时共享**分层级的**高速缓存  

![](https://www.mrbluyee.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/02_%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.JPG)

超线程hyperthreading（同时多线程 simultaneous multi-threading）**允许一个CPU执行多个控制流** 处理器级别的多线程。其减少了模拟并发的需要，其次可以使程序运行得更快。

2. 指令级并行

诸如pipeline流水线等技术让CPU能够同时执行多条指令

能够使处理器在**一个时钟周期内执行超过一条指令**的执行速率 **super-scalar**（超标量）处理器

3. 单指令、多数据的并行

SIMD并行：让一条指令产生多个可以并行的操作

#### 1.9.3 抽象

指令集架构提供了对处理器硬件的抽象，而虚拟机提供对整个计算机的抽象

# 第一部分-程序结构和执行

探寻机器表示核心数据类型的方式。  
机器指令如何操作这样的数据。  
编译器如何将C语言翻译成这样的指令。  

## 第二章-信息的表示和处理

1. E2.35
2. E2.36这两道检测补码乘法溢出的题目
3. 为什么固定大小的补码算数运算的位级操作和无符号运算等价？

三种重要的数字表示：

| 数字表示   |                 |
| ---------- | --------------- |
| 无符号编码（原码） | 大于等于0的整数 |
| 补码       | 有符号整数      |
| 浮点数     | 实数            |

大多数的安全漏洞都是由计算机算数运算的微妙细节引发的。本章学习编码，并学习如何推出数字的表示。  

程序员需要对计算机运算与更为人所熟悉的整数和实数运算之间的关系有更清晰的理解。  

**C++编程语使用和C语言完全相同的数字表示和运算**  

1989年ANSIC标准推出
`C90`(`C89`也就是ANSI C)-->`C99`-->`C11`

gcc的**向后兼容**：新版本编译器对按照早期标准编写的程序进行编译将得到同样的结果

### 2.1 信息存储

计算机通过**地址adress**访问**存储单元**，也就是以8位为一个单元的**字节**，而不是直接访问计算机的位。（汇编里叫内存单元）

对于*机器级*程序，主存被视为一个字节数组，称为**虚拟内存**（virtual memory），标注虚拟内存的是地址，地址的集合被称为**虚拟内存空间virtual address space**

**编译器**和**运行时系统**会将存储空间划分为更加好管理的单元来存放不同的**程序对象**（program object）

每个程序可以简单地视为一个**字节块**，而程序本身就是一个**字节序列**

#### 2.1.1 十六进制表示法

选择**十六进制hexadecimal**的原因：因为二进制表示法**过于冗长**，而十进制和二进制的**转换太麻烦**

**一个字节**
| 进制     | 范围                           |
| -------- | ------------------------------ |
| 十进制   | $[0_{10}, 255_{10}]$           |
| 二进制   | $[00000000_{2}, 11111111_{2}]$ |
| 十六进制 | $[00_{16}, FF_{16}]$           |

C语言中使用`0x`或者`0X`开头的数字来表示十六进制

![](https://www.pianshen.com/images/711/2b719cd148f61f09655c946919f3f3ff.png)

1. 二进制转换为十六进制，**右边开始四位一组**
2. 十六进制转化为二进制，一位十六进制对应四位二进制

##### 练习2.1-转换规则练习：一位十六进制对应四位二进制
0x39A7F8  
0011 1001 1010 0111 1111 1000

1100 1001 0111 1011  
0xC97B

0xD5E4C  
1101 0101 1110 0100 1100

***特殊技巧：满足以下情况的十六进制x可以直接转换*** 
$$x=2^n$$
$$n={i+4j}\;{(i\leq{3})}$$
诀窍在于：**二进制下的n次方意味着数字的结尾有多少个0**（类似于十进制下$10$的$n$次方，数的结尾有多少个零）
因为$0000_{2}=0_{16}$（四个二进制的$0$可以转换为一个十六进制的$0$），所以$0xx$结尾有$j$个$0$。对于$i$，如果$i$分别等于$0,1,2,3$意味着以$1_{2}, 10_{2}, 100_{2}, 1000_{2}$开头，对应十六进制$1_{16}, 2_{16}, 4_{16}, 8_{16}$（数电课上讲的8421顺口溜==）

如果
$$n=11={3+{4}\cdot{2}}$$
那么
$$x=0x800$$

##### 练习2.2-2的n次方快速转换十六进制
| $n$ | $2^{n}$十进制            | $2^{n}$十六进制 |
| --- | ------------------------ | --------------- |
| 9   | 512                      | 0x200           |
| 19  | 1000 0000 0000 0000 0000 | 0x80 000        |
| 14  | 16384                    | 0x4 000         |
| 16  | 1 0000 0000 0000 0000    | 0x10 000        |
| 17  | 2 0000 0000 0000 0000    | 0x20 000        |
| 5   | 32                       | 0x20            |
| 7   | 1000 0000                | 0x80            |

***如何实现十进制和十六进制之间的转换***  

1. 将十进制转化为十六进制

短除法，随后对余数进行倒序

$$
x = q * 16 + r
$$

$$314 156 = 19 634 \cdot 16 + 12(C)$$
$$...$$

2. 将十六进制转化为十进制

$$0x7AF_{16}=F\cdot{16^0} + A\cdot{16^1} + 7\cdot{16^2}$$

##### 练习2.3-两位十六进制和二进制，十进制相互转换
一个字节也就是八位可以由八位二进制，两位十六进制表示  
以后看见两位十六进制，就代表一个字节

| 十进制 | 二进制    | 十六进制 |
| ------ | --------- | -------- |
| 0      | 0000 0000 | 0x00     |
| 167    | 1010 0111 | 0xA7     |
| 62     | 0011 1110 | 0x3E     |
| 188    | 1011 1100 | 0xBC     |
| 55     | 0011 0111 | 0x37     |
| 136    | 1000 1000 | 0x88     |
| 243    | 1111 0011 | 0xF3     |
| 82     | 0101 0010 | 0x52     |
| 172    | 1010 1100 | 0xAC     |
| 231    | 1110 0111 | 0xE7     |

##### 练习2.4-使用十六进制直接计算

$$0x503c+0x8=0x5044$$
$$0x503c-0x40=0x4ffc$$
$$0x503c+64=0x503c+0x40=0x507c$$
$$0x50ea-0x503c=0xae$$

#### 2.1.2 字数据大小

**字长word size**：（用于在虚拟内存空间内寻址的）**指针数据的标称大小**。因为虚拟地址是以字来进行编码的。所以字长决定了虚拟地址空间的最大大小。

>ps：从这个角度理解字长非常犀利

64位机器往往**向后兼容**32位程序  
`linux> gcc -m32 prog.c`  
`linux> gcc -m64 prog.c`  
`-m64`编译出的程序只能在64位设备上运行

32位程序或64位程序指程序的**编译方式**

![基本C数据类型的典型大小（字节为单位）](https://pic4.zhimg.com/80/v2-a51cae659a3dee114fc01cd9286bed0f_1440w.jpg)

`int32_t``int64_t`的出现为了保证程序的可移植性，在C99中规定

C语言不保证char的符号：如果不加`unsigned`，无法保证char类型数据是否有符号，**建议**使用`signed char`来确保char是有符号的。大多数编译器会将char类型编译成有符号。

`char*`代表指针占用内存空间的大小，等于一个字长（不难理解）。ps：但程序理应还要管理指针的类型

*C语言标准对数字范围设置了下界，却没有设置上界*

程序员将`int`类型的变量存储指针的值，在移植到64位机器的时候，会出现问题，因为64位机器的地址需要8字节存放

#### 2.1.3 寻址和字节顺序

多字节对象被存储为**连续的字节序列**  

变量x的地址为**最低位字节的地址**  

**little endian小端法**：将数据的最低有效位放在最前面（低地址开始）  
**big endian大端法**：将数据的最高有效字节放在最前面（低地址开始）  

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS15sqWX2zl_gzF_lFNBVVTH7D16PYEGzcbow&usqp=CAU)

**双端法**（bi-endian）指的是**可以将处理器配置为大端或者小段**，但往往**取决于安装&运行的操作系统**，安卓和IOS都是小端法

1. 字节顺序会对网络通信产生影响，程序必须遵守字节顺序的规则
2. 使用反汇编器disassembler以检查机器级代码（反汇编器将二进制文件转化为汇编）

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;
//sizeof函数返回对象所占用的字节数
void show_bytes(byte_pointer start, size_t len){
    //size_t数据结构大小的首选数据类型
    size_t i;
    for(i = 0; i<len; i++){
        printf(" %.2x", start[i]);
        //整数必须使用至少两位十六进制数字输出
    }
}

void show_int(int x){
    show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x){
    //将指向x的地址指针转化为字节指针
    show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
    show_bytes((byte_pointer) &x, sizeof(void *));
}
```

1. C语言的`typedef`声明提供了一种给数据类型命名的方式，这将改善代码的可读性  
2. `void*`是一种特殊类型的指针，没有相关联的类型信息（参见ansi C，在ansi C之前使用`char*`代表指向一个字节的指针，在ANSI C之后使用`void *`）
3. `size_t` is an unsigned integral data type which is defined in various header files which is used to **represent the size of the object in bytes** and is therefore used as the return type by the `sizeof` operator.  

##### 练习2.5-思考对show_bytes的三次调用

```c
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;

show_bytes(valp, 1);
show_bytes(valp, 2);
show_bytes(valp, 3);
```

指出在小端法和大端法机器上，每次调用的输出值：
|     | 小端法   | 大端法   |
| --- | -------- | -------- |
| A   | 21       | 87       |
| B   | 21 43    | 87 65    |
| C   | 21 43 65 | 87 65 43 |

##### 练习2.6 使用show_int和show_float

我们确定整数`3510593`的十六进制表示为`0x00359141`，而浮点数`3510593.0`的十六进制表示为`0x4A564504`

1. 写出这两个十六进制值的二进制表示

`0000 0000 0011 0101 1001 0001 0100 0001`
`0100 1010 0101 0110 0100 0101 0000 0100`

2. 移动这两个二进制串的相对位置，使得他们匹配的位数最多，有多少位相匹配呢？

`00000000001101011001000101000001`
`\ 01001010010101100100010100000100`

`1010 1100 1000 1010 0000 1`总共21位相同

3. 串中的什么部分不相匹配？

#### 2.1.4 表示字符串

C语言中的字符串被编码为一个以null字符结尾的字符数组

尝试使用`show_bytes`来处理`"12345"`

```c
int main(void){
    char str[] = "12345";
    show_bytes(str, 6);
    return 0;
}

>out:
31 32 33 34 35 00
```
十进制数字x的ascii码正好是`0x3x`，`null空字符`的ascii为`0x00`，在ascii码作为字符码的任何系统上都会得到这个结果，**文本数据比二进制数据有更强的平台独立性**

##### 练习2.7-对show_bytes的调用将输出什么结果？

```c
const char *s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
```

注意，`strlen`不会统计空字符串
`61 62 63 64 65 66`

#### 补充：Unicode

ASCII使用8位二进制，unicode使用32位二进制，每个字符占用4字节。**Java**使用**Unicode**来表示字符

在示例机器上编译某一段程序时，生成的二进制代码一般是不同的，二进制代码往往无法直接移植，程序只是字节序列  

#### 2.1.6 布尔代数简介

$$二元集合\lbrace 0,1\rbrace$$

| 布尔运算（和C语言语法保持一致） | 逻辑运算 | 命题逻辑    |
| ------------------------------- | -------- | ----------- |
| ~                               | NOT      | $\neg$      |
| &                               | AND      | ^           |
| \|                              | OR       | v           |
| ^                               | XOR      | $\bigoplus$ |

##### 练习2.8-位向量的布尔运算
| 运算 | 结果        |
| ---- | ----------- |
| a    | [0110 1001] |
| b    | [0101 0101] |
| ~a   | [1001 0110] |
| ~b   | [1010 1010] |
| a&b  | [0100 0001] |
| a\|b | [0111 1101] |
| a^b  | [0011 1100] |

位运算的分配律：
$$a\And(b|c) = (a\And{b})|(a\And {c})$$

$$a|(b\And{c}) = (a|{b})\And({a|{c}})$$

布尔环的加法逆元为`^`，此外位向量还可以**对有限集合A**进行编码（$A\subseteq{\lbrace{0}, 1, ..., {n-1}\rbrace}$）
$$[a_{\omega-1}, a_{\omega-2}, ..., a_1, a_0]$$
其中$a_i=1$当且仅当$i\in{A}$，位向量
$$a=[0110\ 1001]$$
表示
$$A={\lbrace{0}, 3, 5, {6}\rbrace}$$
有趣的是，对位向量的`&`，`|`，`~`分别对应集合的交并补

##### 练习2.9-三原色
| R   | G   | B   | 颜色   | 补            |
| --- | --- | --- | ------ | ------------- |
| 0   | 0   | 0   | 黑色   | 111（白色）   |
| 0   | 0   | 1   | 蓝色   | 110（黄色）   |
| 0   | 1   | 0   | 绿色   | 101（红紫色） |
| 0   | 1   | 1   | 蓝绿色 | 100（红色）   |
| 1   | 0   | 0   | 红色   | 011（蓝绿色） |
| 1   | 0   | 1   | 红紫色 | 010（绿色）   |
| 1   | 1   | 0   | 黄色   | 001（蓝色）   |
| 1   | 1   | 1   | 白色   | 000（黑色）   |

001 | 010 = 011（蓝绿色）
110 & 011 = 010（绿色）
100 ^ 101 = 001（蓝色）

#### 2.1.7 C位级运算

C语言的位运算只能适用于整型数据

##### 练习2.10-inplace_swap

| 步骤   | \*x                           | \*y                           |
| ------ | ----------------------------- | ----------------------------- |
| 初始   | a                             | b                             |
| 第一步 | a                             | $a\wedge{b}$                  |
| 第二步 | ${a}\wedge{(a\wedge{b})}={b}$ | $a\wedge{b}$                  |
| 第三步 | b                             | ${b}\wedge{(a\wedge{b})}={a}$ |

##### 练习2.11-数组头尾对调

```c
void reverse_array(int a[], int cnt){
    int first, last;
    for(first = 0, last = cnt - 1;
        first <= last;
        first++, last--){
        inplace_swap(&a[first], &a[last]);
    }
}
```

1. 对于一个长度为$cnt=2k+1$的数组，最后一次循环中，变量first和last的值分别是什么？$k$
2. 为什么这时调用函数会将数组元素设置为0？
因为$a\wedge{a}=0$
3. 对reverse做哪些改动就可以消除这个问题？
将循环条件修改为`first<last`

#### 补充：掩码运算

掩码：一串二进制数字，通过与目标数字的按位操作，达到**屏蔽指定位**的需求

`x&0xFF`可以用于求解x的最低有效字节

##### 练习2.12-写出C语言表达式

对任何字长$\omega>=8$都适用

1. x的最低有效字节
`x&0xFF`
2. 除了x的最低有效字节外，其他位都取补，最低有效位保持不变
`x^~0xFF`
3. x的最低有效字节设置为1，其他字节保持不变
`x|0xFF`

##### 练习2.13-VAX计算机

`bis`在m为1的每个位置上将z对应的位设置为1
`bic`在m为1的每个位置将z设置为0

```c
int bis(int x, int m);
int bic(int x, int m);

int bis(int x, int m){
    return x|m;
}

int bic(int x, int m){
    return (~m) & x;
}

int bool_or(int x, int y){
    int result = bis(x, y);
    return result;
}

int bool_xor(int x, int y){
    //帅
    int result = bis(bic(x, y), bic(y, x));
    return result;
}
```

$$aXORb = ({a\wedge\overline{b}}) \vee (({b\wedge\overline{a}}))$$

| a   | b   | $aXORb$ |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |

#### 2.1.8 C逻辑运算

逻辑运算`&&`,`||`,`!`认为所有**非0**的参数都为True，参数**0**表示False。它和位运算是完全不同的。其次，逻辑运算有**短路性质**

##### 练习2.14 计算表达式

假设x和y的字节值分别为`0x66`和`0x39`，填写下表，指明各个C表达式的字节值

`0x66`
`0110 0110`
`1001 1001`

`0x39`
`0011 1001`
`1100 0110`

| 表达式   | 值                  | 表达式              | 值  |
| -------- | ------------------- | ------------------- | --- |
| `x&y`    | `0010 0000`(`0x20`) | `x&&y`              | `1` |
| `x       | y`                  | `0111 1111`(`0x7F`) | `x  |  | y`  | `1` |
| `~x      | ~y`                 | `1101 1111`(`0xDF`) | `!x |  | !y` | `0` |
| `x & !y` | `0000 0000`(`0x00`) | `x && ~y`           | `1` |

##### 练习2.15 实现==

只使用位运算和逻辑运算
`!(x ^ y)`

#### 2.1.9 C移位运算

向左或者向右移动位模式
$$x = [x_{\omega-1}, x_{\omega-2}, ..., x_{2}, x_{1}, x_0]$$

##### 左移
`x<<k`使得`x`左移`k`位，丢弃最高的`k`位，并在右端补`k`个`0`
$$x' = [x_{\omega-1-k}, x_{\omega-2-k}, ..., x_{2}, x_{1}, x_0, 0, 0, 0, ..., 0]$$

作者说$k\in [0, \omega-1]$，也就是位移量不应该大于$\omega-1$，如果${k}\geq{\omega-1}$，这片数据全部为`0`

##### （算数/逻辑）右移

逻辑右移——直接在左边补0
$$x' = [0, ..., 0, x_{\omega-1-k}, x_{\omega-2-k}, ..., x_{k}]$$

算数右移——在左边补$k$个$x_{\omega-1-k}$
$$x' = [x_{\omega-1-k}, ..., x_{\omega-1-k}, x_{\omega-1-k}, x_{\omega-2-k}, ..., x_{k}]$$

C语言**并没有规定到底是采用算数右移还是逻辑右移**，但大多数编译器都对**有符号数**使用**算数右移**。而**无符号数，必须使用逻辑右移**。与之相对，Java中使用`>>>`作为逻辑右移，`>>`作为算数右移

##### k很大

前面讲过，$k\in [0, \omega-1]$，也就是位移量不应该大于$\omega-1$，那如果$k\geq\omega$会发生什么事情？在许多机器上，**移位指令只会考虑位移量的低$\log_{2}\omega$**，也就是说位移量只考虑
$$k'=k \mod \omega$$

所以当$\omega=32$的时候，`<<32`，`>>36`，`>>40`分别表示左移0，右移4，右移8，不过这种行为对于C来说是没有保证的，所以建议让移位量控制在$k\in [0, \omega-1]$，Java则严格按照求模的方式实现

##### 移位运算的优先级问题

移位运算的优先级**比加减法要低**，且按照**从左至右**的运算顺序计算

`1<<2+3<<4`等价于`1<<(2+3)<<4`等价于`(1<<(2+3))<<4)`，拿不准的时候请加上括号！

##### 练习2.16 不同移位运算对字节数的影响

| `x`                 | `x<<3`              | `x>>2`（逻辑）      | `x>>2`（算数）      |
| ------------------- | ------------------- | ------------------- | ------------------- |
| `0xC3`(`1100 0011`) | `0x18`(`0001 1000`) | `0x30`(`0011 0000`) | `0xF0`(`1111 0000`) |
| `0x75`(`0111 0101`) | `0xA8`(`1010 1000`) | `0x1D`(`0001 1101`) | `0x1D`(`0001 1101`) |
| `0x87`(`1000 0111`) | `0x38`(`0011 1000`) | `0x21`(`0010 0001`) | `0xE1`(`1110 0001`) |
| `0x66`(`0110 0110`) | `0x30`(`0011 0000`) | `0x19`(`0001 1001`) | `0x19`(`0001 1001`) |

### 2.2 整数表示

本节中介绍两种整数的编码方式，其一只能表示非负数$\N$，其二能表示整数$\Z$

#### 2.2.1 整型数据类型

1. 无论在什么机器上，负数的范围都比正数大`1`
2. `int`类型都是**4字节**
3. `int_32`和`int_64`是跨平台的
4. `long`类型不可移植

![](https://anduinwrynn.github.io/2018/03/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ACSAPP%E3%80%8B%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180308193232.png)

![](https://img-blog.csdnimg.cn/20200417182022258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F1ZGFueTEwMDYxNzAw,size_16,color_FFFFFF,t_70)

C和C++都支持有符号数，Java不支持无符号数

#### 2.2.2 无符号数编码（原码）

*Binary to unsigned*
$$x = [x_{\omega-1}, x_{\omega-2}, ..., x_{2}, x_{1}, x_0]$$

$$B2U_{\omega}(\vec{x})\vcentcolon=\sum_{i=0}^{\omega-1}{x_{i}2^{i}}$$

举例：
$B2U_4([0001])=1$
$B2U_4([1111])=15$

无符号数编码的范围：

$$B2U_{\omega}(\vec{x}) \in[0, 2^{\omega}-1]$$

无符号编码的唯一性（函数$B2U$是一个**双射**）：

$$\forall x \in [0, 2^{\omega}-1] \Longrightarrow \exist\vec{x}且唯一\exist$$

#### 2.2.3 补码

*Two's - complement*补码将字的最高有效位解释为**负权（negative weight）**
*Binary to two's complement*

$$x = [x_{\omega-1}, x_{\omega-2}, ..., x_{2}, x_{1}, x_0]$$

$$B2T_{\omega}(\vec{x})\vcentcolon=-x_{\omega-1}2^{\omega-1}+\sum_{i=0}^{\omega-2}x_{i}2^{i}$$

观察发现，最高位的负权为$-2^{\omega-1}$

![](https://congchan.github.io/images/two's_complement.png)

补码所能表示的最小值为

$$TMin_{\omega}=-2^{\omega-1}$$

$$TMax_{\omega}=\sum_{i=0}^{\omega-2}2^{i}=2^{\omega-1}-1$$

算上0，位数为$\omega$的补码一共能表示${2^{\omega-1}}\cdot{2}=2^{\omega}$个状态，补码也是一个双射

$$B2T_{\omega}:\{0, 1\} \rightarrow \{TMin_{\omega}, ..., TMax_{\omega}\}$$

我们定义

$$B2T_{\omega} = f(x)$$

$$T2B_{\omega} = f^{-1}(x)$$

##### 练习2.17

| 十六进制$\vec{x}$ | 二进制$\vec{x}$ | $B2U_{4}(\vec{x})$ | $B2T_{4}(\vec{x})$  |
| ----------------- | --------------- | ------------------ | ----------------- |
| 0xE               | [1110]          | $2^3+2^2+2^1=15$   | $-2^3+2^2+2^1=-2$ |
| 0x0               | [0000]          | $0$                | $0$               |
| 0x5               | [1001]          | $9$                | $-8+1=-7$         |
| 0x8               | [1000]          | $8$                | $-8$              |
| 0xD               | [1101]          | $13$               | $-8+4+1=-3$       |
| 0xF               | [1111]          | $15$               | $-8+4+2+1=-1$     |

#### 重要的数字

| 值         | 十六进制表示 |
| ---------- | ------------ |
| $UMax_{w}$ | 0xFF         |
| $TMin_{w}$ | 0x80         |
| $TMax_{w}$ | 0x7F         |
| -1         | 0xFF         |
| 0          | 0x00         |

1. 补码的范围是不对称的

$$|TMin| = |TMax| + 1$$

一半的位模式表示正数，一半的位模式表示负数，但0的表示位模式为0，所以不对称

2. 最大的无符号数值是补码表示的最大值的两倍加一

$$UMax = 2\cdot TMax + 1$$

![](https://codeantenna.com/image/https://img-blog.csdnimg.cn/20200417181955430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F1ZGFueTEwMDYxNzAw,size_16,color_FFFFFF,t_70)
`limits.h`中定义了一组常量`INT_MAX`, `INT_MIN`, `UINT_MAX`描述了整型的取值范围。在C99中引入了`stdint.h`中的`intN_t`和`uintN_t`对不同的n值指定N位有符号和无符号整数。在使用这些宏定义的类型时，需要使用对应的`printf`格式化字符串进行打印

3. 反码Ones's complement（原码取反就是反码）

$$B2O_{\omega}(\vec{x})\vcentcolon=-x_{\omega-1}(2^{\omega-1}-1)+\sum_{i=0}^{\omega-2}x_i\cdot2^{i}$$

4. 原码Sign-magnitude

$$B2S_{\omega}(\vec{x})\vcentcolon=(-1)^{x_{\omega-1}}\cdot (\sum_{i=0}^{\omega-2}x_{i} \cdot 2^{i})$$

这两种编码方式在0这一点都不具有双射属性，对于原码来说[1000 0000 ...]和[0000 0000 ...]都表示为0，反码推知。

```c
short x=12345;
short mx=-12345;

show_bytes((byte_pointer) &x, sizeof(short));
show_bytes((byte_pointer) &mx, sizeof(short));
```

x的十六进制表示为`0x3039`mx的十六进制表示为`0xCFC7`

`0x3039`
`0011 0000 0011 1001`
正数的反码等于原码
`0011 0000 0011 1001`

`0xCFC7`
负数的反码是原码取反+1
取反
`1100 1111 1100 0110`
+1
`1100 1111 1100 0111`

##### 练习2.18 将32位补码转换为十进制

>好吧，`-0x58`就是`-88`，麻了！

| 32位补码十六进制 | 二进制补码            | 十进制                                                                      |
| ---------------- | --------------------- | --------------------------------------------------------------------------- |
| 0x2E0            | [0000 0010 1110 0000] | 736                                                                         |
| -0x58            | [0101 1000]           | 88                                                                          |
| 0x28             | [0010 1000]           | 40                                                                          |
| -0x30            | [0011 0000]           | -48                                                                         |
| 0x78             | [0111 1000]           | 120                                                                         |
| 0x88             | [1000 1000]           | $-1\cdot 2^{7}+8=-121$（因为是32位机器，所以不是负数，应该为：$128+8=136$） |
| 0x1f8            | [0001 1111 1000]      | $256+128+64+32+16+8=504$                                                    |
| 0x8              | [1000]                | 8                                                                           |
| 0xc0             | [1100 0000]           | $128+64=192$                                                                |
| -0x48            | [0100 1000]           | $-1\cdot(64+8)=-72$                                                         |

#### 2.2.4 有符号数和无符号数之间的转换

对于大多数C语言的实现，都是从**位级**考虑，而不是从数值来考虑强制转换。将`short`强制转换为`unsigned short`将**不会改变位值**，但会改变如何解释位值，换句话说只有正数，或者是0，才能正确转换，因为对于非负数来说，原码和反码是一致的
```c
short int v=-12345;
unsigned short uv=(unsigned short) v;
printf("v=%d, uv=%u\n", v, uv);
```
以上代码将会打印`v=-12345, uv=53191`

12345的原码
`0011 0000 0011 1001`
12345的反码
`1100 1111 1100 0110`
12345的补码
`1100 1111 1100 0111`
用原码解释反码，得到`53191`

`unsigned`强制转换为`int`同理。对于大多数C语言实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：**数值可能改变，但位模式坚决不变！**

数学语言描述：

$$T2B_{\omega}:\{TMin_{\omega}, ..., TMax_{\omega}\} \rightarrow \{\vec{x}\}$$

$$U2B_{\omega}:\{0, ..., UMax_{\omega}\} \rightarrow \{\vec{x}\}$$

我们定义：

**反码表示强制转化为无符号（原码）**：
形象解释：先将反码转化为二进制序列，再将二进制序列转化为无符号（原码）
$$T2U_{\omega}(x)\vcentcolon=B2U_{\omega}(T2B_{\omega}(x))$$

**原码表示强制转化为反码**
$$U2T_{\omega}(x)\vcentcolon=B2T_{\omega}(U2B_{\omega}(x))$$

$U2T_{\omega}$和$T2U_{\omega}$这两个函数将描述**绝大多数情况下C语言无符号和反码之间的转化**

例子：
$$T2U_{16}(-12345)=53191$$

$$U2T_{16}(53191)=-12345$$

给定位模式，$|-12345| + |53191| = 65536$

##### 练习2.19 填写T2U4的表格

**练习2.17表格**
| 十六进制$\vec{x}$ | 二进制$\vec{x}$ | $B2U_{4}(\vec{x})$ | $B2T_{4}(\vec{x})$  |
| ----------------- | --------------- | ------------------ | ----------------- |
| 0xE               | [1110]          | $2^3+2^2+2^1=15$   | $-2^3+2^2+2^1=-2$ |
| 0x0               | [0000]          | $0$                | $0$               |
| 0x5               | [1001]          | $9$                | $-8+1=-7$         |
| 0x8               | [1000]          | $8$                | $-8$              |
| 0xD               | [1101]          | $13$               | $-8+4+1=-3$       |
| 0xF               | [1111]          | $15$               | $-8+4+2+1=-1$     |

$$T2U_{\omega}(x)\vcentcolon=B2U_{\omega}(T2B_{\omega}(x))$$

|$x$|$T2U_4(x)$|
|---|---|
|-8|8|
|-3|13|
|-2|15|
|-1|15|
|0|0|
|5|5|

##### **原理：补码转换为无符号数**
对满足$TMin_{\omega}\leq x \leq TMax_{\omega}$:
$$T2U_{\omega}(x)=\begin{cases}
x+2^{\omega} & x<0 \\
x & x\geq 0
\end{cases}$$
>没毛病，观察$B2T_{\omega}$和$B2U_{\omega}$的定义同样可以得出这个结论，对于正数来说，值不变，但对于负数来说，相当于加了$2^{\omega-1}\cdot 2=2^{\omega}$

##### **推导：无符号数转化为补码**

和上述函数是反函数关系（应该不能严格算反函数）

$$B2U_{\omega}(\vec{x})=x_{\omega-1}2^{\omega}+B2T_{\omega}(\vec{x})$$

我们将$\vec{x}=T2B_{\omega}(x)$代入上式

$$B2U_{\omega}(T2B_{\omega}(x))=T2U_{\omega}(x)=x_{\omega-1}2^{\omega}+B2T_{\omega}(T2B_{\omega}(x))=x_{\omega-1}2^{\omega}+x
$$

总结：在$[0, TMax_{\omega}]$这个范围内，有符号数和无符号数之间的直接转换是正确的，该范围之外的数若要在转换时保持准确性，需要加上或减去$2^{\omega}$。最大的负数$-1$转换为无符号类型将变成最大的正数$1$（在$\omega=1$的情况下）

#### 2.2.5 C语言中的有符号和无符号类型

1. C语言没有规定编码方式，但大多数实现都使用**补码**
2. （一般来说）数字默认**有符号**，明确使用无符号数据，使用`123u`或者`123U`
3. 在C中符号数和无符号数之间的强制转换**保持位不变**（前述规则）

C语言中的隐式转换和显示转换
```c
int x, y;
unsigned int p, q;

//显示转换
x = (int) p;
q = (unsigned int)y;

//隐式转换
x = p;
q = y;

//C语言在处理同时包含有符号数和无符号数的表达式时，会将有符号数转换成无符号数
int z = x + p;
```

在`printf()`函数中使用`%u`和`%d`进行不同的C语言位解释，对同一个变量会有不同的解释效果：
```c
int x = -1;

unsigned int u = 2147483648; // = 1后面跟31个0
//（32位二进制下补码能表示的最小的数）

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```

C语言在处理同时包含有符号数和无符号数的表达式时，**会将有符号数转换成无符号数**：
`int z = x + p;`对于标准的算术运算，问题不大（随后将会看到），但对于比较运算符，诸如`>`或者`<`，将会产生错误：`-1<0U`就是一个例子，$-1$在这里由补码表示，如果$0$不添加`U`，也会以补码存储（之前讲过，常量默认为补码编码），如果明确是无符号类型，C语言会**自动**将$-1$解读为**无符号类型**的数据进行比较，显然这个表达式的值为$0$，于是错误就产生了


##### 练习2.21 补码运算的32位机器求值

一些小tips:
1. 32位补码能表示的最小负数为$-2147483647-1 = -2147483648$
2. 32位补码能表示的最大正数为`{2^31}-1=2147483647`
3. 32位原码能表示的最大正数为`{2^32}-1=4,294,967,295`

|表达式|类型|求值|
|---|---|---|
|`-2147483647-1 == 2147483648U`|unsigned int|1|
|`-2147483647-1 < 2147483647`|signed int|1|
|`-2147483647-1U < 2147483647`|?|?|
|`-2147483647-1 < -2147483647`|signed int|1|
|`-2147483647-1U < -2147483647`|?|?|

#### 2.2.6 扩展一个数的位表示

##### 无符号数zero extension

$$
\vec{u} = [u_{\omega-1}, u_{\omega-2}, ..., u_{0}]
$$
$$
\vec{\acute{u}} = [0, 0, ..., 0, u_{\omega-1}, u_{\omega-2}, ..., u_{0}]
$$

##### 补码数的符号扩展

$$
\vec{x} = [x_{\omega-1}, x_{\omega-2}, ..., x_{0}]
$$
$$
\vec{\acute{x}} = [x_{\omega-1}, x_{\omega-1}, ..., x_{\omega-1}, x_{\omega-1}, x_{\omega-2}, ..., x_{0}]
$$

```c
int *ptr_int;
int a = 123;
ptr_int = &a;
for(int i=0;i<sizeof(int);i++){
  printf("%x ", *(ptr_int+i));
}
```

#### 2.2.8 关于有符号和无符号数的建议

##### 练习2.25
```c
float sum_element(float array[], unsigned int len){
  int i;
  float sum = 0;
  for(i = 0; i<=len-1;i++){
    //i<=len-1当len=0的时候结果为1的原因是因为unsigned int无法表示负数，算是数据溢出的错误
    //应该修改为(i=1;i<=len;i++)
    sum += array[i];
  }
  return sum;
}
```
C语言在处理同时包含有符号数和无符号数的表达式时，**会将有符号数转换成无符号数**：`0-1`等价于模数加法，变成`UMax`，总为真


##### 练习2.26-`size_t`定义为`unsigned int`

```c
size_t strlen(const char *s);

int strlonger(char *s, char *t){
  return strlen(s) - strlen(t) > 0;
}
```
两个`unsigned int`类型的值做减法，随后和0比较大小，令人不安！

最好修改成如下形式：
`return strlen(s) > strlen(t);`

>这两个练习都涉及到如何解释整数之间的加减乘除

### 2.3 整数运算

#### 2.3.1 无符号加法

整数加法的**字长膨胀**是持续的，若要完整表示算术运算的结果，不能对字长做任何限制。

$$
x,y \in[0, 2^{\omega})
$$

$$
x+y \in[0, 2^{\omega+1}-2]
$$

无符号数加法$+^{u}_{\omega}$：
$$
x+^{u}_{\omega}y=\begin{cases}
  x+y & x+y<2^{\omega}\\
  x+y-2^{\omega} & x+y>=2^{\omega}
\end{cases}
$$

什么是溢出？

如何检测无符号数溢出？

##### 练习2.27-溢出检查函数

```c
int uadd_ok(unsigned x, unsigned y){
  unsigned z = x+y;
  if(z<x && z<y){
    return 0;
  }
  else{
    return 1;
  }
}
```

什么是阿贝尔群？
模数加法形成了一种叫做**阿贝尔群**的数学结构
1. 群内每个元素都有一个逆元
2. 可交换可结合
3. 存在单位元0

定义无符号数求反$-^{u}_{\omega}x$：
？

#### 2.3.2 补码加法

补码加法的推导。。。

>结论：补码加法和无符号加法都存在溢出，对于溢出的处理方法都是截断高位。两者不同的是，无符号加法只存在正溢出，而补码加法不仅存在正溢出，还存在负溢出。溢出的区间可以被严格证明和推导。补码的区间被划分为三部分
$$x+y\in[-2^{\omega},-2^{\omega-1})$$
$$x+y\in[-2^{\omega-1},2^{\omega-1})$$
$$x+y\in[2^{\omega-1},2^{\omega}]$$

如何检测补码加法的溢出？

##### 练习2.31 阿贝尔群

##### 练习2.32 取相反数

问题，C语言中对`x`做相反数运算`-x`会发生什么？

#### 2.3.3 补码的非

补码的非的定义

#### 2.3.4 无符号乘法

#### 2.3.5 补码乘法

原理：无符号和补码之间的位级等价性（乘法运算的结果位相等）
？

推导：

>虽然完整的位模式可能会不同，但截断后的位级表示是相同的

##### 练习2.37

注意`size_t`被定义为`unsigned int`，在64位机器上的实现给他分配32位，所以`uint64_t`转换成`size_t`依然会损失信息
两类错误：其一是乘法导致的数据溢出；其二是`malloc`函数无法分配堆内存。
```c
uint64_t required_size = ele_cnt * (uint64_t) ele_size;
size_t request_size = (size_t) required_size;
if(required_size != request_size){
  return NULL;
}
void *result = malloc(request_size);
if(result == NULL){
  return NULL;
}
```

#### 2.3.6 乘以常数

整数乘法消耗的时钟周期>>其他整数运算
故编译器倾向于对整数乘法进行优化：使用**移位和加法**运算来代替整数乘法

左移一个数值等价于执行一个与2的幂相乘的**无符号乘法**
公式推导：

*固定大小的补码运算的位级操作与其无符号运算等价*

##### 练习2.38 `LEA`指令执行常数因子乘法

大多数编译器只在需要少量加减法和移位运算的时候对整数乘法采取这样的优化

#### 2.3.7 除以2的幂

**整数除法比整数乘法更慢**，大约三十个时钟周期

**无符号和补码**分别使用**逻辑移位**和**算数移位**

向下取整正值，向上取整负值

事实上，负数的右移依然会导致向下取整，所以需要调整策略

做位扩展意味着什么

感觉向上舍入课本上符号标错了。。。

`~y=-y-1`
如何计算`(x*x)`当x=65535?

### 2.4 浮点数

**小数的二进制表示法**只能对$V=x\cdot2^{y}$进行编码，二进制表示法**只能准确表达这些数**

**Intel8087芯片**对**Intel8086芯片**提供了浮点运算的支持

**1985**年IEEE电气工程师协会推出了**IEEE浮点标准754**，被后世的计算机广泛采纳。IEEE（eye-triple-ee）

对于**小数的二进制表示法**，小数点的左移和右移意味着除以二或乘以二

用这种表示方式所表达的小数相对误差并不大，但是在个别情况下，其绝对误差是惊人的。长时间运行的系统的时钟

#### 2.4.2 IEEE浮点表示

$$V=(-1)^{s}\cdot M\cdot 2^{E}$$

#### 2.4.3 数字示例

越靠近原点越稠密，换句话说，表示的数的绝对值越大，其精度越低

增大阶码浮点数随之增大的原因是小数部分始终控制在$[0,1]$之间

按照无符号对位进行编码，其按照升序排列

1. 推导最小的正非规格化浮点数的位表示，及其值
2. 推导最大的正非规格化浮点数的位表示，及其值
3. 推导最小的正规格化浮点数的位表示，及其值
4. 推导1的正规格化浮点数的位表示
5. 推导最大的正规格化浮点数的位表示，及其值（有个坑，不能把阶码全变成1，否则就是特殊值了。。。）

要把整数转换成浮点数，两种位表示肯定是有重合的部分的，写成十六进制虽然看不出来，但表示成二进制就可以发现了

$[x_{\omega-1}, x_{\omega-2}, ..., x_{2}, x_{1}, x_{0}]$下标从$0$开始，意味着$x_{k}$的基数等于$m^{k}$（假设这个序列的基数为$m$）
[E2.49答案是$2^{n+1}+1$](https://stackoverflow.com/questions/68249156/csapp-3ed-practice-problem-2-49-ieee-floating-point-precision)

#### 2.4.4 舍入

round-to-even这种舍入方式不会使得一组数值的平均数带有统计偏差（假设分布均匀）

对于二进制小数，最低有效位

#### 2.4.5 浮点运算

计算只需保证正确的舍入结果即可

浮点数加法的运算：可交换，但**不可结合**。具有单调性

浮点乘法的运算：封闭性，可交换性，不可结合，在加法上不具有分配性

## 第三章-程序的机器级表示

**计算机执行机器代码**，用字节序列编码低级的操作
**编译器基于语言规则和指令集生成机器代码**
汇编代码是机器代码的文本表示

通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编程一样有效，而高级语言能够跨平台，汇编不能跨平台

学习机器代码&汇编的原因：
最大化优化关键代码段的性能

>精通细节是理解更深更基本概念的先决条件

`AMD`(Advanced micro devices)
**IA32**是**x86-64**的**32**位前身

### 3.1 历史观点

Intel处理器俗称x86

|时间|处理器名称|关键技术|
|---|---|---|
|1978|8086|第一代16位微处理器|
|1985|i386|平坦寻址模式|
|1989|i486|浮点|
|1995|PentiumPro|P6微体系结构（增加条件传送Conditional move）指令|
|1999|Pentium III|二级高速缓存|
|2000|Pentium 4|双精度浮点|
|2004|Pentium 4E|超线程与**EM64T**——Intel对AMD提出的对IA32的64位扩展的实现（也就是x86-64）|
|2006|Core2|第一块多核处理器，多个处理器集成在一块芯片上|

Intel系列芯片有很多个名字：
IA32，Intel32位体系结构（Intel Architecture 32-bits）
x86-64，IA32的64位扩展

>摩尔定律是计算机革命的主要驱动力（晶体管数量每十八个月翻一番）

### 3.2 程序编码

```bash
gcc -Og -o p p1.c p2.c
```

1. C预处理器：扩展源代码，插入#include，扩展#define
2. 编译器：生成p1.c和p2.c的汇编文件
3. 汇编器：将汇编文件转化为二进制目标文件.o（此时全局地址并未被填入）
4. 链接器：将目标文件和库文件合并，生成可执行文件

#### 3.2.1 机器级代码

机器级变成的两种重要抽象：

1. 指令集体系结构&指令集架构（Instruction Set Architecture ISA）
ISA下，每条指令好似都是顺序执行的
2. 虚拟内存

机器级代码将显现一些隐藏的程序状态：
1. 程序计数器（%rip）
2. 整数寄存器文件，也就是一系列64位寄存器（存储地址或者整数数据）
3. 条件码寄存器
4. 向量寄存器，用于存储多个整数，或者浮点数

汇编代码不区分有符号和无符号数，不区分指针类型，甚至不区分整数和指针

```bash
# gcc生成汇编.s文件
gcc -Og -S mstore.c
# gcc生成目标文件
gcc -Og -c mstore.c
# 反汇编器对目标文件进行反汇编
objdump -d mstore.o
```
（查看汇编代码并反向映射到高级语言上）
机器执行的程序只是一个字节序列